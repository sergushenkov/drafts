### Пример 1
Некий файл на диске, про который мы в общем можем знать только размер, становится гораздо понятнее, если мы на следующем уровне абстракции определяем его как текстовый - становится понятнее, какие конкретно байты там могут быть, каких точно не будет. А главное - какие операции над этим файлом возможны и ожидаются
### Пример 2
Текстовый файл из предыдущего примера на более высоком уровне абстракции определим как файл в котором хранится таблица (CSV). Соответственно, уже не все методы подходящие в первом примере будет разумно применять здесь, зато есть смысл определить какие то новые. Структура файла тоже становится ещё конкретней
### Пример 3
Практически все библиотечные классы представляют собой довольно сложные структуры данных с какими-то методами. Разбираясь с ними в коде, не зная их назначения - это крайне сложно и муторно. Но если мы знаем что это, к примеру, коннект к базе данных (абстаркция уровнем выше чем просто код) то становится понятным и структура и возможные методы.

На начальном уровне вхождения в IT - мой код был большей частью одной сплошной простынёй, благо программы были не слишком сложные. Но ошибок была куча, дебагер был практически основной инструмент. Глядя на чужой код, понемногу учился выделять законченные куски кода в функции. А после прохождения курса АСД - начал использовать и объекты с методами. Это сделало код более понятным, его стало легче читать и отлаживать. Дебагер сменился на юнит-тесты. Вот это выделение законченных кусков в отдельные объекты - позволяют оперировать в дальнейшем не несколькими страницами кода, а одной структурой с несколькими доступными методами. Это гораздо проще удержать в голове и гораздо ниже вероятности ошибок