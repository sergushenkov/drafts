Примеры из своего кода не дам :) у меня просто нет мало-мальски больших проектов, особенно таких к которым бы потом обращался. Даже то что на гитхабе - это из серии "выложил и забыл". Код там совсем не "чистый", но в рамках 20..30 строк кода - это не играет особой роли

## 1. Методы, которые используются только в тестах.
Вот с этим сложно - я даже не думал что кто-то так делает, пока не прочитал в рекомендациях так не делать :) Пытался найти пример в гитхабе - но потыкался по ссылкам, всё не то. Чисто имхо, когда отказывался от гетеров/сеттеров - всё можно проверить стандартными методами, просто это требует больше кода в тестах. 

## 2. Цепочки методов.
Сам любил такие цепочки, чтобы несоздавать одноразовые переменные, и в некоторых случаях это нормально (хотя всё равно лучше оформлять, чтобы была одна точка на строку):
```py
# word_feature = line.strip().decode("utf-8")

word_feature = line.strip()
                .decode("utf-8")
```

А вот если в процессе создаётся объект нового типа - то точно не стоит делать это в одну строчку:
```py
# posts = MongoDBIO(save_host, save_port, save_name, save_password, save_database, save_collection).Connection()

mongo_db = MongoDBIO(conn_params)
posts = mongo_db.Connection()
```

## 3. У метода слишком большой список параметров.
Вот это - частая беда, почти в каждом проекте можно найти __init__() на десяток параметров. 
По идее решается передачей этих параметров в виде словаря (список хуже - завязан на порядок перечисления)
Как вариант - можно использовать func(**kwargs)

```py
# class MongoDBIO:
#     # 申明相关的属性
#     def __init__(self, host, port, name, password, database, collection):
#         self.host = host
#         self.port = port
#         self.name = name
#         self.password = password
#         self.database = database
#         self.collection = collection

class MongoDBIO:
    # 申明相关的属性
    def __init__(self, conn_params):
        self.host = conn_params["host"]
        self.port = conn_params["port"]
        self.name = conn_params["name"]
        self.password = conn_params["password"]
        self.database = conn_params["database"]
        self.collection = conn_params["collection"]
```

```py
# def send_mail(smtp_server, from_addr, passwd, to_addr, subject, text='Hello, send by Python...', files=[]):

conn_params = {"smtp_server": smtp_server, 
               "passwd": passwd
}
mail_params = {"from_addr": from_addr, 
               "to_addr": to_addr, 
               "subject": subject, 
               "text": "Hello, send by Python...",
               "files"=[]
}
def send_mail(conn_params, mail_params):
```

## 4. Странные решения. Когда несколько методов используются для решения одной и той же проблемы, создавая несогласованность.

Вот на это примеры точно видел на первой работе - библиотека методов работы с БД - но примеры привести не смогу, код там и остался. 
Такая ситуация возникает, когда проект меняется, появляются новые требования, старые становятся неактуальными - но проект не чистится от legacy.
Примеры в гитхабе не нашёл - надо слишком глубоко вникать в то, что в общем то не нужно (без гарантий найти что-то затребованное)

## 5. Чрезмерный результат. Метод возвращает больше данных, чем нужно вызывающему его компоненту.

Чрезмерный результат в гитхабе тоже найти не удалось - у меня такое было в одноразовых задачах, типа Advents of Code - когда решение меняется, 
но лень переписывать с нуля всё, поэтому просто в return в целом верного метода дополнительно выносится то что надо :) Uglyhack, как говорится,
но с учетом того что это реально на один день - наверное не ужас-ужас. 

В целом из перечисленного - для меня всерьёз актуально "слишком много параметров в методе" и "цепочка методов". С учетом того что в курсе Быстрая прокачка в ООП как раз на это обращалось внимание - думаю смогу отслеживать это в своём коде и сразу делать правильно
