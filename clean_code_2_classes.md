Чтобы найти примеры грязного кода уровня классов и приложений в чужом коде - надо достаточно глубоко в него вникать. Просто жалко тратить время на чужой код, который мне не нужен для работы. В своём коде таких примеров не найти - просто потому что сам код у меня короткий. В работе DE редко когда получается, что кода больше чем экран или два. Поэтому описания случаев будет без примеров  

## 2. Уровень классов.

### 2.1. Класс слишком большой (нарушение SRP), или в программе создаётся слишком много его инстансов (подумайте, почему это плохой признак).
Класс получается слишком большим, когда нет нормального проекта ДО начала программирования, проектирование идёт одновременно с кодированием. Примерно про то же самое - когда происходит модификация легаси под изменившиеся требования без нормального рефакторинга (low cohesion). 

Кейс под много инстансов класса сходу не придумать. Из минусов - явные временные расходы на создание/удаление объекта. Причина - наверное тоже в первую очередь неудачное проектирование (возможно было правильнее однотипные операции сгруппировать), но с другой стороны это может быть и осознанное решение, если эти объекты как то блокируют важный для других систем объект. 

### 2.2. Класс слишком маленький или делает слишком мало.
Тут очевидно - если класс используется только для того, чтобы быть использованным для создания какого то одного другого класса - нет смысла плодить сущности, лучше было бы их объединить (low cohesion).

### 2.3. В классе есть метод, который выглядит более подходящим для другого класса.
Тоже без контекста не представить такую ситуацию. Но выглядит как будто проектирование было по каким то формальным признакам, без ориентации на реальное использование (low cohesion).

### 2.4. Класс хранит данные, которые загоняются в него в множестве разных мест в программе.
Скорее всего тут имеется - high coupling, один класс завязан на множество других, соответственно, если мы вносим в него существенные изменения - надо будет вносить изменения во множестве мест

### 2.5. Класс зависит от деталей реализации других классов.
Тоже пример high coupling - класс должен знать только про интерфейс других классов, не обращая внимания на их реализацию

### 2.6. Приведение типов вниз по иерархии (родительские классы приводятся к дочерним).
Вот этот пример не понял, мне казалось в предыдущем курсе это было как раз рекомендацией

### 2.7. Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых других классов.
Аналог пункта 2.5 

### 2.8. Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы.
Тоже проблема проектирования - зачем создавать методы и атрибуты если не планируется их использовать. Тогда можно было бы обойтись абстрактным классом

## 3. Уровень приложения.

### 3.1. Одна модификация требует внесения изменений в несколько классов.
Само по себе изменение двух-трех других классов это нормально, если меняется интерфейс класса, но если количество изменяемых классов - несколько десятков или модификация не затрагивала интерфейс - то это явно ошибка проектирования (high coupling)

### 3.2. Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн.
Тут вроде очевидно, использовать сложные паттерны в расчете на увеличение нагрузки на несколько порядков через несколько лет - скорее всего будет избыточно, потому что создаёт ненужные сложности в поддержке прямо сейчас ради неясных перспектив