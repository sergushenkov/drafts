В качестве примера раздутости кода приводится кейс с Windows API, где логика работы отдельных функций напрямую зависит от значений их параметров (если второй параметр равен NULL, то первый параметр хранит дескриптор файла, а если нет, то третий параметр содержит текстовое имя файла). В python с такими кейсами пока не сталкивался, но вот в DWH видел прямо один в один. 

Не помню уже конкретику, что-то упрощу, названия 100% перепутаю - но идея думаю будет понятна. Есть таблица с историей какой-то сущности, например банковская карта, и требуется отобрать счета имевшие определённый статус на конкретную дату. Прямым запросом к этой таблице результат не получить - этот статус относится к второстепенным признакам и фиксируется отдельно, вместе с ещё примерно полусотней признаков. В этой дополнительной таблице тоже так просто не получить результат - там для этих 50..100 признаков всего штук пять колонок - внешний ключ к первой таблице, дата изменения, цифровой код признака который был изменён, значение этого признака (или код значения). В итоге, бизнес требования на языке запросов выглядят наподобие 
```sql
select ...
from card
join card_adv ca1 on card.id = ca1.id and ca1.field1 = 15 and ca1.field2 = 53
join card_adv ca2 on card.id = ca2.id and ca2.field1 = 48 and ca2.field2 = 19
...
```
Все эти цифровые значения в полях вспомогательной таблицы совершенно не наглядны и могут быть многократно задействованы в разных местах кода. Запомнить даже не пытаюсь - copy/paste помогает, но появляется риск скопировать что-нибудь лишнее. 

Такой проблемы не было бы, если бы эти поля были явно прописанны в первой таблице, но то ли из-за бизнес-логики, то ли в попытке экономить дисковое пространство, есть то что есть.