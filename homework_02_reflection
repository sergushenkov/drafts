. Конструктор - у меня помимо создания нового пустого списка явно прописано присваивание начальных статусов операциям и задаётся положение курсора - думаю, что в эталонном варианте это тоже подразумевается (в предыдущем задании было)

. head() и tail() у меня прописаны без предусловия - список не пуст. Думал над этим моментом, когда писал абстрактный класс. Сейчас перечитал задание - "установить курсор на первый/последний узел в списке", с другой стороны в теории сказано, что узлы это более слабый уровень абстракции. Мне показалось что правильно было использовать именно значения head и tail, которые задаются для и для пустого списка (значением None). соответственно статусов head_status и tail_status у меня тоже нет
. Только увидел, что у меня вместо tail() прописан push() - не исправил, когда копипастил. Ошибка. Не про понимание, но вообще грубая ошибка. 
. Предусловие right() в эталоне "правее курсора есть элемент", у меня "текущий узел не tail" - формулировка разная, но про одно и то же
. put_right() - у меня в отличии от эталона нет предусловия "список не пуст" (и нет put_right_status), поэтому добавлено постусловие "курсор указывает на текущий узел или на head() (если список был пуст)" 
. Аналогично для put_left() - нет предусловия "список не пуст" (и нет put_left_status), добавлено постусловие "курсор указывает на текущий узел или на head() (если список был пуст)"
. remove() - 1) не поставил предусловие "список не пуст" - та же самая ситуация что и с tail()/head(), когда писал - посчитал пустой список за допустимый вариант. Соответственно, remove_status - нет. 2) в идеальном варианте не прописана ситуация, куда указывает курсор, если удалён последний элемент - в моей концепции он указывает на head списка, т.е. None
. clear() - аналогично, в эталонном варианте в постусловии не прописана ситуация, куда указывает курсор, если удалён последний элемент - в моем варианте он указывает на head списка, т.е. None
. add_tail() - аналогично, в эталонном варианте в постусловии не прописана ситуация, куда указывает курсор после добавления элемента в хвост пустого списка - в моем варианте в этом случае он указывает на head (тот самый добавленный элемент)
. remove_all() - в идеальном варианте не прописано положение курсора, после удаления всех элементов с заданным значением, в т.ч. если сейчас курсор указывает на такой элемент или если после удаления список станет пустым (в моём варианте это есть)
. replace() - в моём варианте нет проверки предусловия - список не пуст, т.е. для пустого списка эта команда отработает так же как add_tail(), поэтому и replace_status нет
. find() - в идеальном варианте поиск идёт только справа от курсора, в моём варианте - если справа элемент не находится, то следом проверяются элементы слева. Мне не кажется это ошибкой - тут главное чтобы это было однозначно определено, тот или иной вариант мы используем. Плюс в find_status у меня есть обозначение ситуации, что курсор перескочил влево от прежней позиции, но нет ситуации, что список пуст

. В итоге получается что ключевое различие - как работать с пустым списком. В идеальном варианте это нестандартная ситуация, в которой большинство команд ничего не делает. В моём варианте во многих случаях это нормально отрабатывает
. Первый минус моего варианта, как мне кажется, в том что приватные переменные класса (head, tail, cursor) могут принимать два разных типа - Node|None, но в эталонном вариант это никак не прописано, и на первый взгляд там будет аналогичная ситуация
. Других минусов не вижу