. Прочитав описание идеального решения - подумал что не знаю как "правильно" должен отрабатывать код, если возникает ошибка при формировании множества в запросе union() - к примеру конечный массив будет больше чем "зашитое" ограничение в 20 тыс. ячеек или возникнет слишком много коллизий (у меня в хеш-таблице встроенно ограничение на три попытки найти подходящую ячейку через смещение). Создать ещё один флаг _status_union? Или возвращать None? Или возвращать кортеж - флаг успешности union плюс результат union?
. Дополнительно определил метод __iter__(), который позволяет последовательно перебирать элементы массива (как раз для запросов Intersection, Union и Difference). Использование этого публичного метода позволяет получить элементы другого множества без использования его приватных свойств и методов
. В остальном - вроде бы всё аналогично