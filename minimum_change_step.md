Для первого варианта взял задание на написание [класса простого дерева](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/simple_tree.py) из курса Алгоритмы и структуры данных. Изначально этот код писал по методике TDD, как я её на тот момент (полгода назад) понимал. Сначала пишу def test_, где в одной функции полностью тестирую один из методов класса, потом пишу собственно метод и исправляю его до тех пор, пока он не будет проходить эту тестирующую функцию.

С нуля переписал этот же класс по методике TDD, но в режиме минимальных шага изменений. Т.е. думаю что сейчас по минимуму могу добавить в метод класса, чтобы это не роняло предыдущие тесты и добавляло функционал, потом внутри def test_ пишу проверки для этого изменения, убеждаюсь, что эти проверки сейчас падают, вношу изменение в метод класса, убеждаюсь, что сейчас проверки отрабатывают как положено, перехожу к следующему шагу. Соответственно вот что получилось - [код](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/simple_tree_1.py) и [тесты](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/tests/test_simple_tree_1.py) к нему.

Старый вариант кода был короче (без учёта метода EvenTrees(), который я сейчас не реализовывал) - 50 строк против 76. Это потому, что в одних методах вызывались другие методы, а в новом варианте такого нет - весь используемый код прописан. На самом деле на 100% не уверен - какой из вариантов лучше. В старом варианте - за счёт того, что реализация вспомогательных вещей прячется внутри вызываемых методов, нагляднее становится функционал метода, с другой стороны - получается много зависимостей внутри методов, это усложнит рефакторинг плюс явно прописывая только нужный код - это улучшает быстродействие метода. Понятно что тут это ускорение - тысячные доли от микросекунд, но на каком то другой задаче выигрыш может быть заметным

А вот при сравнении файлов с тестами - выигрыш на стороне нового варианта - 128 строк против 189, и это при том ещё, что в новом варианте вставлял пустые строки между проверками, которые разделяют отдельные шаги изменения внутри метода. Неожиданно, но объясняется в первую очередь тем, что полгода назад я только осваивал pytest и ООП, поэтому в проверки вставлял даже то, что конкретный метод изменить никак не мог. Так что это не выигрыш подхода - а просто рост уверенности.

В чём наглядно проявляется преимущество подхода - шаги изменений удалось сделать реально маленькими. Посчитал по пустым строкам между проверками - у меня было ровно 20 шагов изменений. Если разделить 76 строк готового кода на 20 - получается в среднем меньше 4 строк на изменение. И это притом, что структура класса с заглушками методов уже была готова. Это реально упрощает непосредственно написание кода. 

Из условных минусов метода минимальных шагов в голову приходят два. 

Первое - над логикой приходится много думать ещё до того как что-то напишешь, не всегда очевидно как можно сделать именно маленький шаг изменения. Но, тут если задуматься, становится очевидно, что это не минус, а очевидный плюс - заставляет структурировать программу. 

Второе - более весомо - мне кажется что если писать проверки для метода итерациями, то есть риск что что-то пропустишь. Когда сосредоточенно думаешь про то, что можно проверить - меньше вариантов что-то пропустить. Думаю можно писать комментариями внутри метода сразу все варианты, какие кейсы стоит проверить, а потом уже постепенно заменять их на код проверок.

Вторую задачу решил попробовать "с нуля". Взял [задание 9 дня из Advent of code 2023](https://adventofcode.com/2023/day/9).

В "обычном режиме" пишу такую заготовку с единственной проверкой прямо в коде:

```python
import os


def answer(all_history):
    return 0


all_history = """0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45"""
result = answer(all_history)
assert result == 68


input_file_path = os.path.dirname(os.path.realpath(__file__)) + "//input.txt"
with open(input_file_path) as fd:
    result = answer(all_history)
    print(result)
```

и дальше переписываю функцию answer(), пока код не отработает до конца.

По поводу применения в нынешней работе - тут всё сложно. Основной инструмент - SQL, можно разбивать длинный код  формирования витрины на отдельные шаги, скидывая промежуточные результаты во временные таблицы, но это приведёт к сильной нагрузке на хранилище и потере производительности - операции чтения/записи самый медленный этап. Поэтому пока оставлю это для своих проектов, которые именно на python
