Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Если класс создаёт конечный объект, обладающий методами, нужными пользователю - например pcypg2.Connection - то он является закрытым. Его используют, но не меняют. 
С другой стороны могут быть классы, которые обладают, к примеру, нужным интерфейсом, который должен быть стандартизирован, для беспроблемной интеграции дальше в системе, но во внутренней реализации возможны варианты, пользователь должен приспосабливать под свою специфику - такие классы должны быть открытыми. Пользователь наследует от них какой то свой пользовательский класс и переписывает часть методов, добавляет новые - получая требуемый функционал. Условно для Kafka существует куча коннекторов, позволяющих получать данные из разных источников, но в отдельном случае имеющиеся могут не подойти. Наследуя от наиболее подходящего, можно добавить ему требуемый функционал или изменить какие то из механизмов, сохраняя интеграцию с системой в целом

```
# открытый класс, функционал которого можно расширять, через наследование
class Mobil():
	def drive()
  def load()

# закрытый класс, имеющий весь необходимый функционал
class Ferrari_Roaring_50S(Mobil):
```