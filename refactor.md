В своих задачах/проектах не нашёл подходящих кейсов, просто нет достаточно больших программ, из-за чего практически все изменения локальные. Что-то похожее нашёл только в учебных задачах по алгоритмам и структурам данных, но само изменение дизайна там не моё :( , я только реализовал это в коде.

Пример 1.

Исходный вариант - реализация двух структур [queue](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/queue_1.py) и [deque](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/deque.py) в классическом варианте. Изменённый вариант - где [обе структуры наследуют АСД](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/queue_asd.py). АСД в данном случае является двухсвязным списком, queue при этом с точки зрения пользователя является односвязным списком, а deque имеет полный функционал и соответственно дополнительные методы. Это не экономит время в два раза, но точно даёт заметный выигрыш во времени разработки. Плюс упрощается тестирование - если всё работает для deque, то и для queue всё будет работать. В целом использование наследования упрощает разработку, снижая количество кода, который надо разработать и отладить.

Пример 2.

Исходный код - реализация [стека](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/stack.py). Здесь метод .pop() возвращает последнее значение стека, при этом удаляя его. [Изменённый вариант](https://github.com/sergushenkov/algorithms-and-data-structures/blob/main/bounded_stack.py) - разделяет гетеры и сетеры. У нас есть метод .peek(), который читает последнее значение стека, и метод .pop(), который именно удаляет последнее значение стека. Разделение на гетеры и сетеры делает код более предсказуемым, понятным. Легче вести отладку и сопровождать код.