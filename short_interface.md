## Призрачное состояние

В статье не было четкой формулировки, что именно под этим подразумевается - "Это отдельная большая и интересная тема", поэтому опираюсь на определение из задания. Но тут для меня тоже возникает неопределённость - "чаще всего это локальные переменные". ИМХО, вместо "локальные" должно быть "глобальные" - тогда складывается, потому что именно глобальные переменные мы можем изменить где то за пределами видимого кода и это может кардинально изменить результаты работы функции. А локальные переменные задаются и доступны именно внутри функции, т.е. никаких состояний внутренних вычислений не добавляют. Хотя, сейчас вспомнил про ООП - там да, переменные объекта могут быть измененны снаружи.

В своём коде использования глобальных переменных избегаю, по-моему было всего два или три таких кейса. Примеров кода не осталось, поэтому даже не вспомню почему решил тогда идти таким путём. Скорее всего было лень всерьёз подумать :(. Примеры с переменными объекта есть, был недолгий период прошлой весной, когда в стиле ООП уже начал писать, а гетеры/сетеры ещё не знал. В курсе "Алгоритмы и структуры данных" практически все внутренние структуры классов были доступны для модификации снаружи. Но кейсы, когда реально это делаю, были только в юнит-тестах - всё таки это учебный курс, поэтому созданные классы в дальнейшем не использовались.

## Чрезмерно узкие погрешности

С этим заданием тупик - понимаю про что это, но в реальной жизни сталкивался скорее с обратным случаем, когда разумно было бы сузить погрешность входных/выходных данных, например через пользовательский тип данных. А вот на чрезмерно узкую погрешность пример не вспомнить. В чужом коде искать проблематично - в хорошем такое вряд ли найду, а плохой без крайней нужды (по работе) изучать - просто время жалко

## Интерфейс сложнее реализации
Вот это как раз вполне типичная история, если читать слово "интерфейс" именно как формальная спецификация. 

1. По работе (формирование витрин в СУБД для обязательной отчетности) - реально проще дать пример кода, кода когда получается примерно то, что нужно и уже на его результате уточнять - что именно надо поменять, чем с нуля описать все эти нюансы словами.

2. Интересный кейс был недавно на техническом интервью по питону - "написать функцию, которая получает на вход список целых чисел и возвращает список, где n-ому элементы соответствует произведение всех остальных элементов исходного списка, кроме него самого". Вроде простое определение, бери и делай, но если требуется именно расписать, как это должно быть запрограммированно (та самая формальная спецификация), то вылезает куча частных случаев - если в списке есть один ноль, если два и более нулей, если нулей нет вообще, если список нулевой длины... Не сравнивал, но думаю по количеству символов код будет короче :)

3. Практически любая функция из [Advent of code](https://github.com/sergushenkov/advent_of_code) занимает три-четыре коротких строчки, а вот описать её гораздо проще через примеры, чем дать формальную спецификацию.