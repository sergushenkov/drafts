## Ожидание "дефолтного" поведения, которого нет.

1. Первый пример - не совсем "программный", скорее организационный. Выйдя на новую работу, был впечатлён, что здесь используется система контроля версий и для СУБД. Т.е. все изменения DDL кода (вью, структура таблиц, функции) сначала вносятся в гит, и только потом накатываются на прод. Готовил изменения по своей задаче - помимо скриптов для деплоя надо подготовить скрипты для отката на всякий случай. Код для скриптов отката взял из гита, самые свежие версии изменяемой вью и для успокоения совести решил испытать их, создал копии вью. Неожиданно - код оказался нерабочим, ссылался на колонку в таблице, которую уже удалили. Посмотрел реальный код вью в базе - там этой ссылки нет. Т.е., хотя контроль версий есть, но не все изменения туда поступают :( Человеческая привычка сделать просто побеждает. Моя ошибка - предположил что раз есть возможность бест практис, то все её используют. Ошибка команды - оставили возможность разработчикам править код руками, в обход SVC.

2. Требовалось исключить из витрины строки с определенными значениями поля - сходу добавил проверку в условие where: tbl.field not in (1, 2, 3) и неожиданно потерял 90% нужных строк. Неожиданно, потому что строк с такими значениями в этом поле всего доли процента. Начал смотреть что в поле у исключённых строк. Оказалось null. Точно, проверка null not in (1, 2, 3) вернёт null, хотя на уровне "житейской" логики ожидаешь True. Моя ошибка. Знание что будет в результате сравнения в голове было сразу, но не рассмотрел этот вариант, зациклился только на конкретных значениях.

3. Третий пример из сферы IT подобрать не смог - всё таки у дата инженера чужой код в основном "публичный", без неявных договорённостей (вот только совсем недавно в день отлёта увидел что у меня авиабилет без багажного места. Раньше никогда не сталкивался с подобной ситуацией, по дефолту ожидал что все билеты имеют багажное место килограмм на 20. Увы, пришлось доплачивать на регистрации. Надо читать информацию на сайте авиаперевозчика)

## Исключаем возможные казусы

1. Пользовательские типы данных для параметров объекта - когда метод в принципе не может принять или вернуть данные не того типа (например длину в метрах, если ожидается что она будет в см, хотя и там и там визуально просто число) - это очень мощный инструмент предотвращения ошибок. В своих проектах пока не использовал, только в рамках учебных задач на эту тему - просто собственный код довольно короткий, страница или две - не больше. Но вот как раз на новом месте ожидаю что пригодится - тут дата-инженер наполовину разработчик, будет возможность попрактиковаться

2. В СУБД аналогичные пользовательские типы (https://postgrespro.ru/docs/postgresql/9.4/sql-createtype) также позволяют предотвращать ошибки и дополнительный плюс - пользовательские типы (в первую очередь - перечисление) зачастую требуют меньший размер памяти по сравнению с обычным int например, что может дать неплохую экономию на нескольких миллиардов строк

3. В SQL-скриптах значение null в каком либо поле может поломать вроде бы рабочую на всех остальных кейсах конструкцию (см. п.2 из предыдущего раздела). По хорошему в таблицах недолжно быть таких полей, и в принципе это легко исключить, если прописать дефолтные значения для полей таблицы или наложить ограничение not null на поля. Правда, зачастую процессы уже выстроенны с ошибками и просто нет ни прав ни возможностей их менять, но это уже другая история :)